- **ArrayList和LinkedList的底层原理和区别**
	- ArrayList和LinkedList都是`Collection`接口中`List`子接口的实现类，用来存放有序的、可以重复的数据（主要用于替换数组，是一种“动态”的数组“
	- ArrayList底层使用**动态数组**存储元素。可以通过索引快速访问元素。线程不安全，效率高。而LinkedList底层使用**双向链表** 存储元素
---
- **HashMap的底层原理**
	- JDK1.8 之前 `HashMap` 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。HashMap 通过 key 的 `hashcode` 经过扰动函数处理过后得到 hash 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。所谓扰动函数指的就是 HashMap 的 `hash` 方法。使用 `hash` 方法也就是扰动函数是为了防止一些实现比较差的 `hashCode()` 方法 换句话说使用扰动函数之后可以减少碰撞。
	- JDK1.8之后，`HashMap`底层使用**数组+链表+红黑树**的方式实现。具体的，当链表长度大于阈值时，会首先进行判断，如果当前数组长度小于64，那么会对**数组进行扩容**。反之，会将链表转化为**红黑树**进行处理

---
- **ConcurrentHashMap的底层原理**
- **synchronized和voliate的区别**
- **hashmap的查找过程**